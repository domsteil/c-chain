{"version":3,"sources":["../src/TransportNodeHid.js"],"names":["listenDevicesDebounce","listenDevicesPollingSkip","listenDevicesDebug","isDisconnectedError","e","message","indexOf","TransportNodeHid","path","Promise","resolve","HID","device","info","getDeviceInfo","deviceModel","serialNumber","parseInt","exchangeBusyPromise","close","isSupported","list","map","d","setListenDevicesDebounce","delay","setListenDevicesPollingSkip","conditionToSkip","setListenDevicesDebug","debug","log","listen","observer","unsubscribed","then","devices","descriptor","productId","next","type","events","stop","onAdd","onRemove","on","unsubscribe","removeListener","channel","Math","floor","random","packetSize","disconnected","setDisconnected","emit","writeHID","content","data","i","length","push","write","reject","readHID","read","res","buffer","Buffer","from","exchange","apdu","exchangeAtomicImpl","toString","framing","blocks","makeBlocks","result","acc","getReducedResult","reduceResponse"],"mappings":"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","file":"TransportNodeHid.js","sourcesContent":["//@flow\n\nimport HID from \"node-hid\";\nimport Transport from \"@ledgerhq/hw-transport\";\nimport type {\n  Observer,\n  DescriptorEvent,\n  Subscription\n} from \"@ledgerhq/hw-transport\";\nimport hidFraming from \"@ledgerhq/devices/lib/hid-framing\";\nimport { identifyUSBProductId } from \"@ledgerhq/devices\";\nimport type { DeviceModel } from \"@ledgerhq/devices\";\nimport { TransportError, DisconnectedDevice } from \"@ledgerhq/errors\";\nimport getDevices from \"./getDevices\";\nimport listenDevices from \"./listenDevices\";\n\nlet listenDevicesDebounce = 500;\nlet listenDevicesPollingSkip = () => false;\nlet listenDevicesDebug = () => {};\n\nconst isDisconnectedError = e =>\n  e && e.message && e.message.indexOf(\"HID\") >= 0;\n\n/**\n * node-hid Transport implementation\n * @example\n * import TransportNodeHid from \"@ledgerhq/hw-transport-node-hid\";\n * ...\n * TransportNodeHid.create().then(transport => ...)\n */\nexport default class TransportNodeHid extends Transport<string> {\n  /**\n   *\n   */\n  static isSupported = (): Promise<boolean> =>\n    Promise.resolve(typeof HID.HID === \"function\");\n\n  /**\n   *\n   */\n  static list = (): Promise<string[]> =>\n    Promise.resolve(getDevices().map(d => d.path));\n\n  /**\n   *\n   */\n  static setListenDevicesDebounce = (delay: number) => {\n    listenDevicesDebounce = delay;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesPollingSkip = (conditionToSkip: () => boolean) => {\n    listenDevicesPollingSkip = conditionToSkip;\n  };\n\n  /**\n   *\n   */\n  static setListenDevicesDebug = (debug: boolean | ((log: string) => void)) => {\n    listenDevicesDebug =\n      typeof debug === \"function\"\n        ? debug\n        : debug\n        ? (...log) => console.log(\"[listenDevices]\", ...log)\n        : () => {};\n  };\n\n  /**\n   */\n  static listen = (\n    observer: Observer<DescriptorEvent<string>>\n  ): Subscription => {\n    let unsubscribed = false;\n    Promise.resolve(getDevices()).then(devices => {\n      // this needs to run asynchronously so the subscription is defined during this phase\n      for (const device of devices) {\n        if (!unsubscribed) {\n          const descriptor: string = device.path;\n          const deviceModel = identifyUSBProductId(device.productId);\n          observer.next({ type: \"add\", descriptor, device, deviceModel });\n        }\n      }\n    });\n    const { events, stop } = listenDevices(\n      listenDevicesDebounce,\n      listenDevicesPollingSkip,\n      listenDevicesDebug\n    );\n\n    const onAdd = device => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"add\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    };\n    const onRemove = device => {\n      if (unsubscribed || !device) return;\n      const deviceModel = identifyUSBProductId(device.productId);\n      observer.next({\n        type: \"remove\",\n        descriptor: device.path,\n        deviceModel,\n        device\n      });\n    };\n    events.on(\"add\", onAdd);\n    events.on(\"remove\", onRemove);\n    function unsubscribe() {\n      unsubscribed = true;\n      events.removeListener(\"add\", onAdd);\n      events.removeListener(\"remove\", onRemove);\n      stop();\n    }\n    return { unsubscribe };\n  };\n\n  /**\n   * if path=\"\" is not provided, the library will take the first device\n   */\n  static async open(path: string) {\n    if (path) {\n      return Promise.resolve(new TransportNodeHid(new HID.HID(path)));\n    }\n    const device = getDevices()[0];\n    if (!device) throw new TransportError(\"NoDevice\", \"NoDevice\");\n    return Promise.resolve(new TransportNodeHid(new HID.HID(device.path)));\n  }\n\n  device: HID.HID;\n  deviceModel: ?DeviceModel;\n\n  channel = Math.floor(Math.random() * 0xffff);\n  packetSize = 64;\n  disconnected = false;\n\n  constructor(device: HID.HID) {\n    super();\n    this.device = device;\n    // $FlowFixMe\n    const info = device.getDeviceInfo();\n    this.deviceModel =\n      info && info.serialNumber\n        ? identifyUSBProductId(parseInt(info.serialNumber, 16))\n        : null;\n  }\n\n  setDisconnected = () => {\n    if (!this.disconnected) {\n      this.emit(\"disconnect\");\n      this.disconnected = true;\n    }\n  };\n\n  writeHID = (content: Buffer): Promise<void> => {\n    const data = [0x00];\n    for (let i = 0; i < content.length; i++) {\n      data.push(content[i]);\n    }\n    try {\n      this.device.write(data);\n      return Promise.resolve();\n    } catch (e) {\n      if (isDisconnectedError(e)) {\n        this.setDisconnected();\n        return Promise.reject(new DisconnectedDevice(e.message));\n      }\n      return Promise.reject(e);\n    }\n  };\n\n  readHID = (): Promise<Buffer> =>\n    new Promise((resolve, reject) =>\n      this.device.read((e, res) => {\n        if (!res) {\n          return reject(new DisconnectedDevice());\n        }\n        if (e) {\n          if (isDisconnectedError(e)) {\n            this.setDisconnected();\n            return reject(new DisconnectedDevice(e.message));\n          }\n          reject(e);\n        } else {\n          const buffer = Buffer.from(res);\n          resolve(buffer);\n        }\n      })\n    );\n\n  /**\n   * Exchange with the device using APDU protocol.\n   * @param apdu\n   * @returns a promise of apdu response\n   */\n  exchange = (apdu: Buffer): Promise<Buffer> =>\n    this.exchangeAtomicImpl(async () => {\n      const { debug, channel, packetSize } = this;\n      if (debug) {\n        debug(\"=>\" + apdu.toString(\"hex\"));\n      }\n\n      const framing = hidFraming(channel, packetSize);\n\n      // Write...\n      const blocks = framing.makeBlocks(apdu);\n      for (let i = 0; i < blocks.length; i++) {\n        await this.writeHID(blocks[i]);\n      }\n\n      // Read...\n      let result;\n      let acc;\n      while (!(result = framing.getReducedResult(acc))) {\n        const buffer = await this.readHID();\n        acc = framing.reduceResponse(acc, buffer);\n      }\n\n      if (debug) {\n        debug(\"<=\" + result.toString(\"hex\"));\n      }\n      return result;\n    });\n\n  setScrambleKey() {}\n\n  /**\n   * release the USB device.\n   */\n  async close(): Promise<void> {\n    await this.exchangeBusyPromise;\n    this.device.close();\n  }\n}\n"]}